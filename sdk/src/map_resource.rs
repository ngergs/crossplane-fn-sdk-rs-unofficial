use crate::crossplane::Resource;
use crate::error::error_invalid_data;
#[cfg(feature = "k8s-openapi")]
use k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;
#[cfg(feature = "k8s-openapi")]
use k8s_openapi::Metadata;
use serde::de::{DeserializeOwned, IntoDeserializer};
use serde::Serialize;
use serde_json::Value;
use std::any::type_name;
use std::collections::HashSet;
use std::io::Error;

/// Type mapping from a crossplane resource (protobuf json format) into a rust type.
/// All trait functions have default implementations using `serde` that should be sufficient for common use cases.
pub trait TryFromResource: DeserializeOwned {
    /// Reads the Crossplane resource value and maps it to a Rust type (like those generated by Kopium).
    /// Crossplane uses `structpb.Struct` [here](https://github.com/crossplane/crossplane/blob/b896358bbce847819ad04277d099a568020f4d31/internal/xfn/utils.go#L54)
    /// to convert `unstructured.Unstructured` to dynamic protobuf values. Unfortunately this erases all integer types
    /// and all we are left with is float. Serde won't accept this for integer typed fields.
    /// We therefore try to convert every float field into i64 and keep it This function
    /// traverses the input value and try to cast all float values to i64 values. It only changes those where the cast succeeds.
    ///
    /// # Errors
    /// - If the .resource field is `None`.
    /// - If marshalling the `resource` to an intermediate JSON representation fails.
    /// - If unmarshalling the type-fixed JSON representation to the target type fails.
    /// - On any mapping incompatibility between the types.
    /// - If any fields would be ignored during unmarshalling. Except `apiVersion` and `kind`
    ///   which are e.g. in `kube` and `k8s-openapi` not modelled as struct fields but are associated
    ///   to the type not the instantiation. Therefore, they are ignored from the perspective of `serde`.
    fn try_from_resource(value: Resource) -> Result<Self, Error> {
        let resource = value
            .resource
            .ok_or(error_invalid_data(".resource field not set"))?;

        let mut value = serde_json::to_value(resource)?;
        json_value_cast_float_to_i64(&mut value);
        from_value_strict(value, ["apiVersion", "kind"])
    }

    /// Reads the Crossplane resource value and maps it to a Rust type (like those generated by Kopium).
    /// Crossplane uses `structpb.Struct` [here](https://github.com/crossplane/crossplane/blob/b896358bbce847819ad04277d099a568020f4d31/internal/xfn/utils.go#L54)
    /// to convert `unstructured.Unstructured` to dynamic protobuf values. Unfortunately this erases all integer types
    /// and all we are left with is float. Serde won't accept this for integer typed fields.
    /// We therefore try to convert every float field into i64 and keep it This function
    /// traverses the input value and try to cast all float values to i64 values. It only changes those where the cast succeeds.
    ///
    /// # Errors
    /// - If the value is `None`.
    /// - If the .resource field is `None`.
    /// - If marshalling the `resource` to an intermediate JSON representation fails.
    /// - If unmarshalling the type-fixed JSON representation to the target type fails.
    /// - On any mapping incompatibility between the types.
    fn try_from_option_resource(value: Option<Resource>) -> Result<Self, Error> {
        let resource = value.ok_or(error_invalid_data("resource is `None`"))?;
        Self::try_from_resource(resource)
    }
}

/// Takes a Kubernetes object and transforms it into a Crossplane managed resource
pub trait TryIntoResource: Sized + Serialize {
    /// Takes the object and returns a Crossplane managed resource.
    ///
    /// # Errors
    /// - On any mapping incompatibility between the types.
    fn try_into_resource(self) -> Result<Resource, Error> {
        let obj_json = serde_json::to_value(self)?;
        let Value::Object(_) = &obj_json else {
            return Err(error_invalid_data(
                "expected structured object as Kubernetes resource",
            ));
        };

        let obj_struct = serde_json::from_value(obj_json)?;
        Ok(Resource {
            resource: Some(obj_struct),
            ..Default::default()
        })
    }
}

#[cfg(feature = "k8s-openapi")]
impl<T> TryFromResource for T where T: DeserializeOwned + Metadata<Ty = ObjectMeta> {}
#[cfg(feature = "k8s-openapi")]
impl<T> TryIntoResource for T where T: Serialize + Metadata<Ty = ObjectMeta> {}

/// This function traverses the json value and tries to cast all float values to i64 values. It only changes those where the cast succeeds without data loss.
fn json_value_cast_float_to_i64(val: &mut Value) {
    match val {
        Value::Number(num) => {
            #[allow(clippy::cast_possible_truncation)]
            if let Some(num_float) = num.as_f64()
                && num_float.fract() == 0.0
            {
                *val = Value::from(num_float as i64);
            }
        }
        Value::Object(o) => {
            o.iter_mut()
                .for_each(|(_, v)| json_value_cast_float_to_i64(v));
        }
        Value::Array(a) => {
            a.iter_mut().for_each(json_value_cast_float_to_i64);
        }
        Value::Null | Value::Bool(_) | Value::String(_) => {}
    }
}

/// Deserializes the `value` and errors if any field is ignored by utilizing [`serde_ignored`].
///
/// # Errors
/// - On any deserialization error.
/// - On successful deserialization if fields have been ignored.
fn from_value_strict<T: DeserializeOwned, const N: usize>(
    value: Value,
    allowed_ignored_fields: [&str; N],
) -> Result<T, Error> {
    let mut unused = HashSet::new();
    let result: T = serde_ignored::deserialize(value.into_deserializer(), |path| {
        let path_str = path.to_string();
        if !allowed_ignored_fields.iter().any(|el| *el == path_str) {
            unused.insert(path.to_string());
        }
    })?;
    if !unused.is_empty() {
        return Err(error_invalid_data(format!(
            "unused fields found during marshalling into `{}`: {unused:?}",
            type_name::<T>()
        )));
    }
    Ok(result)
}

#[cfg(test)]
mod tests {
    #[cfg(feature = "k8s-openapi")]
    use crate::map_resource::from_value_strict;
    use crate::map_resource::json_value_cast_float_to_i64;
    use k8s_openapi::api::core::v1::ConfigMap;
    use serde::de::DeserializeOwned;
    use serde::Serialize;
    use std::fmt::Debug;

    fn json_value_cast_roundtrip_check<T>(values: Vec<T>)
    where
        T: Serialize + DeserializeOwned + Clone + PartialEq + Debug,
    {
        for value in values {
            let mut json_value = serde_json::to_value(value.clone()).unwrap();
            json_value_cast_float_to_i64(&mut json_value);
            let value_roundtrip: T = serde_json::from_value(json_value).unwrap();
            assert_eq!(value, value_roundtrip);
        }
    }

    #[test]
    /// Verifies that floats can be deserialized after `json_value_cast_float_to_i64`
    fn json_value_cast_float_roundtrip_test() {
        json_value_cast_roundtrip_check(vec![3.0, 3.24, 0.0, -3.0, -3.24]);
    }

    #[test]
    /// Verifies that ints can be deserialized after `json_value_cast_float_to_i64`
    fn json_value_cast_int_roundtrip_test() {
        json_value_cast_roundtrip_check(vec![3, 0, -3]);
    }

    #[test]
    #[cfg(feature = "k8s-openapi")]
    fn unmarshall_with_unsupported_field() {
        let res_json = r#"{"apiVersion": "v1",
"kind": "ConfigMap",
"metadata": {
  "name": "test",
  "surprise": "hello"
}}"#;
        let value = serde_json::from_str(res_json).unwrap();
        let _ = from_value_strict::<ConfigMap,_>(value,[])
            .is_err_and(|e|e.to_string()== "unused fields found during marshalling into `k8s_openapi::v1_33::api::core::v1::config_map::ConfigMap`: {\"metadata.?.surprise\"}");
    }
}
