use crate::crossplane::Resource;
use crate::errors::error_invalid_data;
#[cfg(feature = "k8s-openapi")]
use k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;
#[cfg(feature = "k8s-openapi")]
use k8s_openapi::Metadata;
use serde::de::DeserializeOwned;
use serde::Serialize;
use serde_json::Value;
use std::io::Error;

/// `TryFromResource` handles type mapping via serde.
/// All trait functions have default implementations that should be sufficient for common use cases.
/// It is used to clarify that `.status` and not `.spec` value of the resource will be used
pub trait TryFromResource: Sized + DeserializeOwned {
    /// Reads the Crossplane resource value and maps it to a Rust type (like those generated by Kopium).
    /// Crossplane uses `structpb.Struct` [here](https://github.com/crossplane/crossplane/blob/b896358bbce847819ad04277d099a568020f4d31/internal/xfn/utils.go#L54)
    /// to convert `unstructured.Unstructured` to dynamic protobuf values. Unfortunately this erases all integer types
    /// and all we are left with is float. Serde won't accept this for integer typed fields.
    /// We therefore try to convert every float field into i64 and keep it This function
    /// traverses the input value and try to cast all float values to i64 values. It only changes those where the cast succeeds.
    ///
    /// # Errors
    /// - If the .resource field is `None`.
    /// - If marshalling the `resource` to an intermediate JSON representation fails.
    /// - If unmarshalling the type-fixed JSON representation to the target type fails.
    /// - On any mapping incompatibility between the types.
    fn try_from_resource(value: Resource) -> Result<Self, Error> {
        let resource = value
            .resource
            .ok_or(error_invalid_data(".resource field not set"))?;

        let mut value = serde_json::to_value(resource)?;
        json_value_cast_float_to_i64(&mut value);
        Ok(serde_json::from_value(value)?)
    }
}

pub trait TryFromOptionResource: TryFromResource {
    /// Reads the Crossplane resource value and maps it to a Rust type (like those generated by Kopium).
    /// Crossplane uses `structpb.Struct` [here](https://github.com/crossplane/crossplane/blob/b896358bbce847819ad04277d099a568020f4d31/internal/xfn/utils.go#L54)
    /// to convert `unstructured.Unstructured` to dynamic protobuf values. Unfortunately this erases all integer types
    /// and all we are left with is float. Serde won't accept this for integer typed fields.
    /// We therefore try to convert every float field into i64 and keep it This function
    /// traverses the input value and try to cast all float values to i64 values. It only changes those where the cast succeeds.
    ///
    /// # Errors
    /// - If the value is `None`.
    /// - If the .resource field is `None`.
    /// - If marshalling the `resource` to an intermediate JSON representation fails.
    /// - If unmarshalling the type-fixed JSON representation to the target type fails.
    /// - On any mapping incompatibility between the types.
    fn try_from_option_resource(value: Option<Resource>) -> Result<Self, Error> {
        let resource = value.ok_or(error_invalid_data("resource is `None`"))?;
        Self::try_from_resource(resource)
    }
}

impl<T: TryFromResource> TryFromOptionResource for T {}

/// Takes a Kubernetes object and transforms it into a Crossplane managed resource
pub trait TryIntoResource: Sized + Serialize {
    /// Takes the object and returns a Crossplane managed resource.
    ///
    /// # Errors
    /// - On any mapping incompatibility between the types.
    fn try_into_resource(self) -> Result<Resource, Error> {
        let obj_json = serde_json::to_value(self)?;
        let Value::Object(_) = &obj_json else {
            return Err(error_invalid_data(
                "expected structured object as Kubernetes resource",
            ));
        };

        let obj_struct = serde_json::from_value(obj_json)?;
        Ok(Resource {
            resource: Some(obj_struct),
            ..Default::default()
        })
    }
}

#[cfg(feature = "k8s-openapi")]
impl<T> TryFromResource for T where T: DeserializeOwned + Metadata<Ty = ObjectMeta> {}
#[cfg(feature = "k8s-openapi")]
impl<T> TryIntoResource for T where T: Serialize + Metadata<Ty = ObjectMeta> {}

/// This function traverses the json value and tries to cast all float values to i64 values. It only changes those where the cast succeeds without data loss.
fn json_value_cast_float_to_i64(val: &mut Value) {
    match val {
        Value::Number(num) => {
            #[allow(clippy::cast_possible_truncation)]
            if let Some(num_float) = num.as_f64()
                && num_float.fract() == 0.0
            {
                *val = Value::from(num_float as i64);
            }
        }
        Value::Object(o) => {
            o.iter_mut()
                .for_each(|(_, v)| json_value_cast_float_to_i64(v));
        }
        Value::Array(a) => {
            a.iter_mut().for_each(json_value_cast_float_to_i64);
        }
        Value::Null | Value::Bool(_) | Value::String(_) => {}
    }
}
