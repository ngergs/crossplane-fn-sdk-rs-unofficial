pub mod function;

// Below follow mostly input/output mappings. The core logic is in function.rs

/// The composite used as input for this function.
pub mod composite_resource {
    use crossplane_rust_sdk_unofficial::crossplane::Resource;
    use std::io::{Error};

    include!("generated/xrd.rs");

    impl TryFrom<Option<Resource>> for Config {
        type Error = Error;

        fn try_from(value: Option<Resource>) -> Result<Self, Self::Error> {
            crossplane_rust_sdk_unofficial::from_resource(value)
        }
    }
}

/// The output managed resources generated by this composite function.
pub mod output {
    use crossplane_rust_sdk_unofficial::crossplane::Resource;
    use k8s_openapi::api::core::v1::ConfigMap;
    use k8s_openapi::apimachinery::pkg::apis::meta::v1::ObjectMeta;
    use k8s_openapi::Metadata;
    use serde::Serialize;
    use std::io::{Error, ErrorKind};

    /// `TryFromStatus` works the same way as `TryFrom`.
    /// It is used to clarify that `.status` and not `.spec` value of the resource will be used
    /// to construct the object.
    pub trait TryFromStatus: Sized {
        type Error;
        /// Reads the resource value from fields under `.status`.
        ///
        /// # Errors
        /// - On any mapping incompatibility between the types.
        fn try_from_status(value: Resource) -> Result<Self, Self::Error>;
    }

    /// Takes a Kubernetes object and transforms it into a Crossplane managed resource
    pub trait TryIntoResource: Sized {
        type Error;
        /// Takes the object and returns a Crossplane managed resource.
        ///
        /// # Errors
        /// - On any mapping incompatibility between the types.
        fn try_into_resource(self) -> Result<Resource, Self::Error>;
    }

    impl TryFromStatus for ConfigMap {
        type Error = Error;

        fn try_from_status(value: Resource) -> Result<Self, Self::Error> {
            let res_json = serde_json::to_value(
                value
                    .resource
                    .ok_or(Error::new(ErrorKind::InvalidData, "resource missing"))?,
            )?;
            Ok(serde_json::from_value(res_json)?)
        }
    }

    impl<T: Metadata<Ty = ObjectMeta> + Serialize> TryIntoResource for T {
        type Error = Error;

        fn try_into_resource(self) -> Result<Resource, Self::Error> {
            let obj_json = serde_json::to_value(self)?;
            let serde_json::Value::Object(_) = &obj_json else {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "expected structured object as Kubernetes resource",
                ));
            };

            let obj_struct = serde_json::from_value(obj_json)?;
            Ok(Resource {
                resource: Some(obj_struct),
                ..Default::default()
            })
        }
    }
}
